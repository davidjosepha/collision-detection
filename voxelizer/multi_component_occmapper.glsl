// This shader takes as input a multi-component slicemap (as generated by the
// shader in multi_component_slicemapper.glsl) for a sub-volume of a larger
// model space, and overwrites that region of a full-volume antialiased voxel-
// occupancy map at the model's native resolution (that is, with the voxel size
// implied by the unit length of the model space).
// 
// Each voxel in the output summarizes a small cube of image voxels.  We use the
// term "image region" to refer to the image voxels that correspond to a single
// occupancy-map voxel.  A single occupancy-map voxel has several slots in which
// to store occupancy data.  Each slot is a 32-bit value.  The upper 16 bits
// store the ID for a component, and the lower 16 bits store the number of
// voxels in the corresponding image region that are occupied by the model
// component with that ID.
// 
// This program uses the fragment shader to operate on different output voxels
// in parallel.  This is a hack to get CUDA-like parallel operation on a regular
// 3D grid of values.  So the nominal input to the shader is actually a bunch of
// quads that generate the appropriate fragments.  The instance IDs for the
// quads go from 0 to Z*C-1, where Z is the native image-space Z resolution of
// the sub-volume, and C is the number of components stored in the slicemap.
// 
// By Jadrian Miles, February 2013.
// Updated by Jadrian in March 2013 to implement open-slot tracking.

#version 420 core
#extension GL_NV_gpu_shader5 : enable
#extension GL_EXT_shader_image_load_store : enable

//#define ZOOM 4
// The above #define is actually prepended to the file by a call in
// multi_component_occmapper.cpp to set the correct zoom level.  It's left in
// place here to make the code easier to reuse in a different context.

// The slicemap is the input to our shader, and is structured in the same way
// as the output slicemap of multi_component_slicemapper.glsl.  Conceptually,
// it is a binary-valued map of the zoomed image space.
layout(size1x32) coherent restrict readonly
  uniform uimage3D slicemap;

// The occmap (occupancy map) is the output of our shader.  It's a 3D image,
// with Y and Z dimensions matching the native image resolution of the model
// volume.  The X dimension is equal in size to the X-size of the volume,
// multiplied by the number of component slots.
layout(size1x32) coherent restrict
  uniform uimage3D occmap;

// The occmap open-slot image is 3D, with dimensions matching the native image
// resolution of the full volume.  The value in each voxel is the lowest occmap
// slot currently empty in the occmap.
layout(size1x32) coherent restrict
  uniform uimage3D occmap_open_slots;

// The Z region LUT is 2D: the X dimension of the LUT is the same size as the
// X dimension of the slicemap (the number of slabs), and the Y dimension is the
// same size as the Z dimension of the native image space.  For a given depth z
// and a Z-slab index s, the LUT stores the bit mask for the corresponding image
// region in the Z direction at (X=s, Y=z).
layout(size1x32) coherent restrict readonly
  uniform uimage2D z_region_mask_lut;

// Once the image region in Z has been masked out by a mask looked up in the Z-
// region LUT, the result needs to be right-shifted to the least significant
// bits for bit-counting.  The masked-Z shift LUT stores the correct shift
// distances for all corresponding non-zero Z-region masks.
layout(size1x32) coherent restrict readonly
  uniform uimage2D masked_z_shift_lut;

// The ID map stores, at index c, the true ID for the component stored in the
// slicemap with fake component ID c.
layout(size1x32) coherent restrict readonly
  uniform uimage1D id_map;

// Low corner of the rendering box in model space.
uniform ivec3 box_pos;
// Dimensions of the rendering box in model space.
uniform vec3 box_size;
// Number of Z slabs in the slicemap.
uniform uint slicemap_num_z_slabs;
// Number of component slots in the occmap.
uniform uint occmap_num_component_slots;
// Number of bits in the occmap field used to encode that alpha value.
uniform uint occmap_num_alpha_bits;
// A LUT to count bits in m-bit numbers, where m is the zoom level.
uniform uint bit_counter[(1 << ZOOM)];

#ifdef _VERTEX_
layout(location = 0) in vec3 in_pos;
// gl_InstanceID simultaneously encodes both the native-resolution Z-position of
// the desired fragments, as well as the component ID to look up in the
// slicemap.  It does this by acting as a linear index into a notional 2-D array
// whose fastest-changing index is the fragment Z position (in [0, box_size.z))
// and whose second index is the component ID.  This ordering allows us to leave
// the maximum component ID defined only implicitly by the maximum value of
// gl_InstanceID.
in int gl_InstanceID;

// Output variables to pass to the fragment shader.  We use flat shading on the
// IDs because they are derived from gl_InstanceID, which is fixed for any given
// mesh triangle (and thus consistent across all vertices in that mesh).  Smooth
// shading does linear interpolation in world space, which is exactly
// what we want for the fragment position: it is a linear interpolation of the
// positions of the vertices.
smooth out vec3 frag_pos;
flat out uint slicemap_component_id;
flat out uint true_component_id;
void main() {
  // gl_Position for vertices inside the rendering box must be transformed into
  // the canonical view volume ([-1,1] in each dimension) in order for fragments
  // to render.
  gl_Position = vec4((in_pos-(box_size/2.0)) / (box_size/2.0), 1);
  
  // frag_pos tells the fragment shader which native-space voxel to process.
  frag_pos = vec3(in_pos.xy, gl_InstanceID % uint(box_size.z));
  // slicemap_component_id tells where to find this component in the slicemap.
  slicemap_component_id = gl_InstanceID / uint(box_size.z);
  // true_componet_id gets recorded in the occmap.  Left-shifting here (for
  // storage in the high bits of the occmap voxel value) saves computations in
  // the fragment shader.
  true_component_id = imageLoad(id_map, int(slicemap_component_id)).r
    << occmap_num_alpha_bits;
}
#endif

#ifdef _FRAGMENT_
smooth in vec3 frag_pos;
flat in uint slicemap_component_id;
flat in uint true_component_id;
flat in uint occmap_slot_id;
void main() {
  // The native position in the *subvolume*.
  ivec3 native_pos = ivec3(floor(frag_pos));
  // Within this subvolume, indices in the slicemap start at zero.
  ivec3 slicemap_pos = ZOOM*native_pos;
  // We work with the full occmap volume, though, so we have to offset the
  // subvolume origin to the appropriate position in the occmap.
  ivec3 occmap_pos = native_pos + box_pos;
  
  // Count up all the occupied voxels in the image region in the slicemap.
  uint count = 0;
  for(uint s = 0; s < slicemap_num_z_slabs; ++s) {
    uint mask = imageLoad(z_region_mask_lut, ivec2(s, native_pos.z)).r;
    uint shift = imageLoad(masked_z_shift_lut, ivec2(s, native_pos.z)).r;
    // TODO: This "if" is optional.  Theoretically, it makes no sense to do a
    // bunch of work when we know the mask is all zeros.  However, on a parallel
    // architecture it may actually be more efficient to avoid branching, even
    // if we would apparently lose a ton of clock cycles on useless work.
    if(mask > 0) {
      for(uint dy = 0; dy < ZOOM; ++dy) {
        for(uint dx = 0; dx < ZOOM; ++dx) {
          uint slice = imageLoad(slicemap,
            ivec3(slicemap_pos.xy + uvec2(dx,dy),
                  slicemap_component_id * slicemap_num_z_slabs + s)).r;
          uint shifted = (slice & mask) >> shift;
          count += bit_counter[shifted];
        }
      }
    }
  }
  
  // This "if" is necessary --- the shader generates fragments for the entire
  // volume, but most of those voxels are not occupied by the component.  We
  // don't want to use up occmap slots to store zeros.
  if(count > 0) {
    uint occmap_slot_id = imageAtomicAdd(occmap_open_slots, occmap_pos, 1u);
    imageStore(occmap, ivec3(occmap_pos.x * occmap_num_component_slots +
                             occmap_slot_id, occmap_pos.yz),
               uvec4(true_component_id | count));
  }
}
#endif
